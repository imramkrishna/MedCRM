generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model admin {
  id                 Int                  @id @default(autoincrement())
  email              String               @unique
  password           String
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  adminLoginSessions adminLoginSessions[]
}

model distributor {
  id                       Int                        @id @default(autoincrement())
  ownerName                String
  companyName              String
  email                    String                     @unique
  phone                    String                     @unique
  address                  String
  password                 String
  createdAt                DateTime                   @default(now())
  updatedAt                DateTime                   @updatedAt
  distributorLoginSessions distributorLoginSessions[]
  orders                   Order[]
  activityLogs             activityLog[] // Added relation field
}

model distributorLoginSessions {
  id            Int         @id @default(autoincrement())
  distributorId Int         @unique
  refreshToken  String      @unique
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  distributor   distributor @relation(fields: [distributorId], references: [id])
}

model adminLoginSessions {
  id           Int      @id @default(autoincrement())
  adminId      Int      @unique
  refreshToken String   @unique
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  admin        admin    @relation(fields: [adminId], references: [id])
}

model pendingRegistration {
  id          Int      @id @default(autoincrement())
  companyName String
  email       String   @unique
  ownerName   String
  phone       String   @unique
  address     String
  password    String
  message     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Enhanced Order Management
model Order {
  id               String       @id @default(cuid())
  orderNumber      String       @unique @default(uuid()) // Human-readable order number
  distributorId    Int?
  //for sample orders and checking functionality
  paymentStatus    String       @default("unpaid")
  specialOrder     Boolean      @default(false)
  status           OrderStatus  @default(PENDING)
  paymentMode      PaymentMode? @default(CASH_ON_DELIVERY)
  transactionId    String?      @unique
  confirmationSlip String? // Optional field for confirmation slip URL or reference
  // Financial calculations with Decimal for precision
  subTotal         Decimal      @db.Decimal(10, 2)
  taxAmount        Decimal      @default(0) @db.Decimal(10, 2)
  discountAmount   Decimal      @default(0) @db.Decimal(10, 2)
  totalAmount      Decimal      @db.Decimal(10, 2)

  // Order metadata
  notes                 String?
  internalNotes         String? // Admin-only notes
  requestedDeliveryDate DateTime?

  // Approval workflow
  approvedAt      DateTime?
  rejectedAt      DateTime?
  rejectionReason String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  distributor          distributor?           @relation(fields: [distributorId], references: [id])
  orderItems           OrderItem[]
  orderHistory         OrderHistory[]
  paymentStatusRequest paymentStatusRequest[]

  @@index([distributorId, status])
  @@index([orderNumber])
  @@index([createdAt])
  @@index([status])
  @@map("orders")
}

model paymentStatusRequest {
  id               Int       @id @default(autoincrement())
  orderId          String    @unique
  PaymentMode      String
  TxnId            String?   @unique
  ConfirmationSlip String? // Optional field for confirmation slip URL or reference
  requestedAt      DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  paymentRequestAt DateTime? @default(now())
  paymentUpdatedAt DateTime? @updatedAt
  order            Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@map("payment_status_requests")
}

model OrderItem {
  id        String @id @default(cuid())
  orderId   String
  productId Int
  quantity  Int

  // Pricing with enterprise precision
  unitPrice       Decimal @db.Decimal(10, 2) // Price at order time
  listPrice       Decimal @db.Decimal(10, 2) // Original product price
  discountPercent Decimal @default(0) @db.Decimal(5, 2)
  discountAmount  Decimal @default(0) @db.Decimal(10, 2)
  lineTotal       Decimal @db.Decimal(10, 2) // Final line amount

  // Product snapshot for historical accuracy
  productSku         String
  productName        String
  productDescription String?
  productBrand       String?
  productCategory    String?

  // Item-specific data
  notes                 String?
  requestedDeliveryDate DateTime?

  // Fulfillment tracking
  quantityFulfilled Int       @default(0)
  fulfilledAt       DateTime?

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product product @relation(fields: [productId], references: [id])

  @@unique([orderId, productId])
  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

// Complete audit trail for order changes
model OrderHistory {
  id           String       @id @default(cuid())
  orderId      String
  fromStatus   OrderStatus?
  toStatus     OrderStatus
  changeReason String?
  notes        String?
  metadata     Json? // Additional data as JSON
  createdAt    DateTime     @default(now())

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([createdAt])
  @@map("order_history")
}

// Enhanced Product Model with enterprise features
model product {
  id          Int     @id @default(autoincrement())
  sku         String  @unique
  barcode     String  @unique // Unique barcode for each product
  name        String
  description String?
  category    String?
  brand       String?
  color       String?

  // Enterprise pricing with Decimal precision
  listPrice Decimal  @db.Decimal(10, 2)
  costPrice Decimal? @db.Decimal(10, 2)

  // Enhanced inventory management
  stockQuantity    Int  @default(0)
  reservedQuantity Int  @default(0) // Reserved for pending orders
  minOrderQuantity Int  @default(1)
  maxOrderQuantity Int?

  // Product specifications
  weight     Decimal? @db.Decimal(8, 3)
  dimensions Json? // {length, width, height, unit}

  // Product lifecycle
  isActive          Boolean   @default(true)
  isDiscontinued    Boolean   @default(false)
  dateOfManufacture DateTime?
  dateOfExpiry      DateTime?

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  orderItems OrderItem[]

  @@index([sku])
  @@index([category])
  @@index([isActive])
  @@index([brand])
  @@map("products")
}

model activityLog {
  id            Int          @id @default(autoincrement())
  distributorId Int?
  action        String
  timestamp     DateTime     @default(now())
  details       Json?
  distributor   distributor? @relation(fields: [distributorId], references: [id])

  @@index([distributorId])
  @@map("activity_logs")
}

// Enhanced enum with more granular statuses
enum OrderStatus {
  DRAFT // Keep temporarily
  PENDING
  CONFIRMED
  APPROVED // Keep temporarily
  REJECTED // Keep temporarily
  PROCESSING
  READY_TO_SHIP // Keep temporarily
  SHIPPED
  DELIVERED
  CANCELLED
  RETURNED // Keep temporarily
  PARTIALLY_FULFILLED // Keep temporarily
}

enum PaymentMode {
  CHEQUE_ON_DELIVERY
  CASH_ON_DELIVERY
  WALLET
  ONLINE_BANKING
  CARD
}
